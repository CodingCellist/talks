%\documentclass[compress]{beamer}
\documentclass[compress,handout]{beamer}

%%%%% PREAMBLE %%%%%

% we want to draw diagrams (turns out not like this though)
\usepackage{tikz}

% figures in a presentation look better without "Figure"
\usepackage{caption}
\captionsetup[figure]{labelformat=empty}

%% % for Idris syntax highlighting
%% \usepackage[styles]{idrislang}

\usepackage{minted}
\setminted{
  fontsize=\small,
  breaklines=true
}

% slide url at the end
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  urlcolor=purple
}

% N.B. For some reason, things don't build without this...
\usepackage{todonotes}
\setuptodonotes{inline} % for things to work nicely with beamer

\usetheme{metropolis}

\title{Type-Level Property Based Testing}

\author{{\bfseries Thomas Ekstr{\" o}m Hansen} \& Edwin Brady}
\date{TyDe '24 {\textemdash} 9\textsuperscript{th} September 2024}

\definecolor{staBlue}{HTML}{00539b}
\definecolor{staMidGreen}{HTML}{00853f}
\definecolor{staDarkGreen}{HTML}{005953}
\setbeamercolor{frametitle}{bg=staDarkGreen}


%%%%% DOCUMENT %%%%%

% /!\     N.B.: `fragile` required for listing to work     /!\

\begin{document}

\maketitle


%% MARK: Overview
\begin{frame}
  \frametitle{Overview}

  \begin{itemize}
    \item<1-> Stateful systems fit nicely with dependently typed models
    \item<2-> Dependent types are difficult to get right, how do we test them?
    \item<3-> A general framework for stateful, testable, and dependently typed
              models
  \end{itemize}

\end{frame}


%% MARK: Motivation
\begin{frame}
  \frametitle{Motivation}

  \begin{itemize}
    \item<1-> Many systems exhibit Finite State Machine (FSM)-like behaviour
    \item<2-> These can be modelled using dependent types
    \begin{itemize}
      \item<2-> Dependent types are difficult to get right
    \end{itemize}
    \item<3-> We want to increase confidence in our types
  \end{itemize}

\end{frame}


%% MARK: Approach


%% MARK: Contributions


%% MARK: Disclaimer
\begin{frame}
  \frametitle{Disclaimer: ``increase confidence''}

  \begin{center}
    {\Large
    This is not a proof technique
    }

    {\large
    But hopefully, it helps us catch errors faster and provides guarantees that
    our model behaves as intended
    }
  \end{center}

\end{frame}


%% MARK: Stateful systems
\begin{frame}
  \frametitle{Stateful Computer Systems}

  \begin{itemize}
    \item<1-> Stateful systems are ubiquitous
    \item<2-> Embedded controllers for automatic doors, ATMs, and network
              protocols
    \item<3-> These are all stateful
    \item<4-> And we would very much like them to be correct
  \end{itemize}

\end{frame}


%% MARK: Spectrum
\begin{frame}[fragile]
  \frametitle{Spectrum of Verification}

  \hspace*{-5mm}  % to fit the bounding box of the tikz diagram
  % ~~probably~~ DEFINITELY cursed
  \begin{tikzpicture}[> = stealth, semithick]
    % scale %

    % left half
    \draw [dashed, <-] (-0.2, 0) -- (0.4, 0) ;
    \draw (0.4, 0) -- (3.8, 0) ;

    % middle dashed
    \draw [dashed] (3.8, 0) -- (6.6, 0) ;

    % right half
    \draw (6.6, 0) -- (10, 0) ;
    \draw [dashed, ->] (10, 0) -- (10.6, 0) ;


    % ticks / vertical lines %

    % leftmost tick (constructive proofs)
    \draw<2-> (0.8, -0.5) -- (0.8, 0.5) ;
    
    % tick for model checking
    \draw<3-> (3, -0.5) -- (3, 0.5) ;

    % tick for Quickcheck
    \draw<4-> (7.3, -0.5) -- (7.3, 0.5) ;

    % rightmost tick (unit tests)
    \draw<5-> (9.4, -0.5) -- (9.4, 0.5) ;


    % scale labels %

    \node at (0, -0.3) {\scriptsize Stronger} ;
    \node at (10.3, -0.3) {\scriptsize Weaker} ;


    % text boxes with arrows %

    % constructive proofs
    \node<2->
          [draw, rounded corners,
          text width=7em,
          align=flush center,
          color=staBlue]% 
          at (1.5, 2.3)
          (tbox-prf)
          \bgroup
          \scriptsize
          Constructive proofs
          \vspace*{-2pt}
          \tiny
          % LaTeX looks beautiful and nice
          % Also LaTeX:
          \setlength{\leftmargini}{2em}
          \begin{itemize}%[leftmargin=*]
            \item CoQ/RoCQ, Agda, Isabelle \vspace*{-3pt}
            \item Very strong guarantees \vspace*{-3pt}
            \item Hard to write
          \end{itemize}
          \egroup
          ;
    \draw<2-> [thick, color=staBlue] (tbox-prf) -- (0.8, 0.5) ;

    % model checking
    \node<3->
          [draw, rounded corners,
          text width=7.5em,
          align=flush center,
          color=staBlue]% 
          at (2.5, -2)
          (tbox-mc)
          \bgroup
          \scriptsize
          Model checking
          \vspace*{-3pt}
          \tiny
          \setlength{\leftmargini}{2em}
          \begin{itemize}%[leftmargin=*]
            \item \textsc{Spin, Uppaal}  \vspace*{-3pt}
            \item Exhaustive search  \vspace*{-3pt}
            \item State Explosion Problem  \vspace*{-3pt}
            \item Risk translation errors
          \end{itemize}
          \egroup
          ;
    \draw<3-> [thick, color=staBlue] (tbox-mc) -- (3, -0.5) ;

    % property-based testing
    \node<4->
          [draw, rounded corners,
          text width=8em,
          align=flush center,
          color=staBlue]% 
          at (6, 2)
          (tbox-qc)
          \bgroup
          \scriptsize
          Property-based testing
          \vspace*{-3pt}
          \tiny
          \setlength{\leftmargini}{2em}
          \begin{itemize}%[leftmargin=*]
            \item QuickCheck, JQF \vspace*{-3pt}
            \item Generates inputs for each property \vspace*{-3pt}
            \item Might miss cases
          \end{itemize}
          \egroup
          ;
    \draw<4-> [thick, color=staBlue] (tbox-qc) -- (7.3, 0.5) ;

    % tdd
    \node<5->
          [draw, rounded corners,
          text width=8em,
          align=flush center,
          color=staBlue]% 
          at (7.5, -2)
          (tbox-tdd)
          \bgroup
          \scriptsize
          Unit testing / TDD
          \vspace*{-3pt}
          \tiny
          \setlength{\leftmargini}{2em}
          \begin{itemize}%[leftmargin=*]
            \item JUnit, unittest, cfg(test) \vspace*{-3pt}
            \item Easy to write \vspace*{-3pt}
            \item Only tests what the programmer has thought of
          \end{itemize}
          \egroup
          ;
    \draw<5-> [thick, color=staBlue] (tbox-tdd) -- (9.4, -0.5) ;

  \end{tikzpicture}

\end{frame}


%% MARK: TyDe
\begin{frame}
  \frametitle{What about Type-Driven Development?}

  \begin{itemize}
    \item<1-> Dependently Typed languages like Agda and Idris
    \item<2-> Can construct advanced types and embedded DSLs
    \item<3-> And the type checker then helps verify the program
    \item<4-> Fits somewhere in the middle
  \end{itemize}
\end{frame}


%% MARK: ATM Diagram
\begin{frame}
  \frametitle{The ATM state machine}

  \begin{figure}
    \centering
    \includegraphics[alt={A state diagram of an ATM, with circles for each state: Ready, CardInserted, and Session; labelled arrows between the states; with the labels containing the transition names: Insert, Dispense, CheckPIN(Correct), CheckPIN(Incorrect), and Eject.},width=0.8\framewidth]{ATM.png}
    %% \Description{A state diagram of an ATM, with circles for each state: Ready,
    %%              CardInserted, and Session; labelled arrows between the states;
    %%              with the labels containing the transition names: Insert,
    %%              Dispense, CheckPIN(Correct), CheckPIN(Incorrect), and Eject.}
  \end{figure}
  \vspace*{-1cm}

\end{frame}


%% MARK: ATM States
\begin{frame}[fragile]
  \frametitle{Datatype for the ATM states}

  \begin{columns}
  \begin{column}{0.3\framewidth}
    \begin{minted}[gobble=6]{Idris}
      data ATMState
        = Ready
        | CardInserted
        | Session
    \end{minted}
  \end{column}

  \begin{column}{0.65\framewidth}
    \begin{figure}
    \includegraphics[alt={The state diagram from slide 7.},width=\textwidth]{ATM.png}
    %% \Description{The ATM diagram from slide 7}
    \end{figure}
  \end{column}
  \end{columns}

\end{frame}


%% MARK: ATM Results
\begin{frame}[fragile]
  \frametitle{Datatype for ATM operation results}

  \begin{columns}
  \begin{column}{0.3\framewidth}
    \begin{minted}[gobble=6]{Idris}
      data PINok 
        = Correct
        | Incorrect
    \end{minted}
    \pause
  \end{column}

  \begin{column}{0.65\framewidth}
    \begin{figure}
    \includegraphics[alt={The state diagram from slide 7.},width=\textwidth]{ATM.png}
    %% \Description{The state diagram from slide 7.}
    \end{figure}
  \end{column}
  \end{columns}

  \vspace*{1cm}

  \pause

  Everything which does not have a result returns Unit {\textemdash}
  \mintinline{Idris}|()|

\end{frame}


\begin{frame}[fragile]
  \frametitle{State Transition Function}

  \begin{columns}
  \begin{column}{0.5\framewidth}
    \begin{minted}[gobble=6]{Idris}
      ChkPINfn : PINok -> ATMState
      ChkPINfn Correct = Session
      ChkPINfn Incorrect = CardInserted
    \end{minted}
  \end{column}
  \hspace*{-7mm}
  \begin{column}{0.55\framewidth}
    \begin{figure}
    \includegraphics[alt={The state diagram from slide 7.},width=\textwidth]{ATM.png}
    %% \Description{The state diagram from slide 7.}
    \end{figure}
  \end{column}
  \end{columns}

\end{frame}


%% MARK: CheckPIN
\begin{frame}[fragile]
  \frametitle{Dependent State Transition}

  \begin{minted}[gobble=4]{Idris}
    data ATM : (t : Type) -> ATMState -> (t -> ATMState) -> Type where
      CheckPIN :  (pin : Int)
               -> ATM PINok CardInserted ChkPINfn
  \end{minted}
  \vspace*{-5mm}
  \hspace*{1cm} \vdots
  \begin{minted}[gobble=4]{Idris}
      (>>=) : ATM a s1 s2f -> ((x : a) -> ATM b (s2f x) s3f) -> ATM b s1 s3f
  \end{minted}

\end{frame}


%% MARK: ATM Operations
\begin{frame}[fragile]
  \frametitle{ATM Indexed State Monad}

  \begin{minted}[gobble=4]{Idris}
    data ATM : (t : Type) -> ATMState -> (t -> ATMState) -> Type where
      CheckPIN :  (pin : Int)
               -> ATM PINok CardInserted ChkPINfn
      Insert : ATM () Ready (const CardInserted)
      Dispense : (amt : Nat) -> ATM () Session (const Session)
      Eject : ATM () st (const Ready)
      Pure : (x : t) -> ATM t (stFn x) stFn
      (>>=) : ATM a s1 s2f -> ((x : a) -> ATM b (s2f x) s3f) -> ATM b s1 s3f
  \end{minted}
\end{frame}


%% MARK: ISM Prog.g
\begin{frame}[fragile]
  \frametitle{Why Is This Neat?}

  \begin{itemize}
    \item<1-> We declare our intended start and end state in the type
              \begin{minted}{Idris}
prog : ATM () Ready (const Ready)
              \end{minted}
    \item<2-> And the type-checker verifies that we don't use operations
              incorrectly
              \begin{minted}[breaklines=false]{Idris}
prog = do                    -- We start in Ready
  Insert  --------------------- Ready to CardInserted
  Correct <- CheckPIN 1234  --- CI to Session
    | Incorrect => <...>  ----- (or stay in CI)
  Dispense 42  ---------------- Stay in Session
  Eject  ---------------------- Return to Ready
              \end{minted}
  \end{itemize}

\end{frame}


%%% %% MARK: ISM Definition
%%% \begin{frame}
%%%   \frametitle{Model: Indexed State Monads (ISMs)}
%%% 
%%%   \begin{itemize}
%%%     \item<1-> Declare a datatype for the states
%%%     \item<2-> Declare datatypes for the possible results (if any) of the
%%%               operations
%%%     \item<3-> Declare a datatype with constructors for each operation, such
%%%               that:
%%%       \begin{itemize}
%%%         \item<4-> The type checker can follow the state transitions
%%%         \item<5-> We can program with the operations
%%%       \end{itemize}
%%%   \end{itemize}
%%% 
%%% \end{frame}
%%% 
%%% 
%%% %% MARK: General ISM
%%% \begin{frame}[fragile]
%%%   \frametitle{Generalised ISMs}
%%% 
%%%   \begin{itemize}
%%%     \item<1-> The ISM pattern can be generalised
%%%     \item<2-> Bind and pure are formulaic, operations are ``just'' semantics
%%%   \end{itemize}
%%%   
%%%   \pause
%%% 
%%%   \begin{minted}[gobble=4]{Idris}
%%%     op : forall st . (t' : Type) -> st -> (t' -> st) -> Type
%%% 
%%%     data Prog :  {0 stT : _} -> (opT : (t' : _) -> stT -> (t' -> stT) -> Type) -> ... -> Type where
%%%       Pure : (x : t) -> Prog opT t (stFn x) stFn
%%%       Op : {0 opT : (t’ : _) -> stT -> (t’ -> stT) -> Type}
%%%          -> opT t st stFn -> Prog opT t st stFn
%%%       (>>=) : Prog opT resT1 st1 stFn1
%%%             -> ((x : resT1) -> Prog opT resT2 (stFn1 x) stFn2)
%%%             -> Prog opT resT2 st1 stFn2
%%%   \end{minted}
%%% 
%%% \end{frame}


%% MARK: Loop program
\begin{frame}[fragile]
  \frametitle{Dependent Types Only Get Some Things Right}

  \begin{columns}
  \begin{column}{0.47\framewidth}
    {\color{red} Rejected by the type-checker:}
    \vspace*{1mm}
    \begin{minted}[fontsize=\footnotesize,breaklines=false]{Idris}
badProg : ATM ()
            Ready (const Ready)
badProg = do
  Insert
  let pin = 1234
  Correct <- CheckPIN pin
    | Incorrect => InsertCard
  Dispense 42
  -- We never Eject, so we
  -- never come back to
  -- `Ready'
    \end{minted}
    \vspace*{2.5mm}
  \end{column}

  \pause  % first show the bad, then the dubious

  \vrule{}

  \begin{column}{0.53\framewidth}
    {\color{orange} Accepted by the type-checker:}
    \vspace*{1mm}
    \begin{minted}[breaklines=false,fontsize=\footnotesize]{Idris}
loopProg : ATM ()
             Ready (const Ready)
loopProg = do
    InsertCard
    let pin = 4321
    loopIncorrect pin
  where
    loopIncorrect : Nat -> ATM ()
                      CardInserted
                      (const Ready)
    loopIncorrect p = do
      Incorrect <- CheckPIN p
        | Correct => -- <...>
      loopIncorrect p
    \end{minted}
    \vspace*{-6mm}
  \end{column}
  \end{columns}
\end{frame}


%% MARK: Why problem?
\begin{frame}
  \frametitle{Why Is This a Problem?}

  \begin{itemize}
    \item<1-> As-is, the PIN can be brute forced!
    \item<2-> We expect an ATM to reject the card after 3 PIN attempts
    \begin{itemize}
      \item<2-> Not to be permanently unavailable if we retry forever
    \end{itemize}
    \item<3-> However, the programmer is unlikely to catch this
    \item<4-> The model looks correct and rigorous, after all
    \item<5-> Programming with it will catch most errors
    \item<6-> And the type-checker is happy with our sequence of operations
  \end{itemize}
\end{frame}


%% \begin{frame}
%%   \frametitle{How do we solve this?}
%% 
%%   \begin{itemize}
%%     \item<1-> We could spot the issue when it happens
%%     \begin{itemize}
%%       \item<2-> Someone will (hopefully) spot the issue during development
%%       \item<3-> Or, worst case, spot it when it happens after deployment
%%     \end{itemize}
%%     \item<4-> And then we update our model and everything is good
%%     \item<5-> Why not try to spot it \textit{automatically} before either of
%%               those?
%%     \item<6-> Modelling can clearly go wrong, so how do we increase our
%%               confidence in the models?
%%   \end{itemize}
%% \end{frame}


%% \begin{frame}
%%   \frametitle{The eternal problem with verification systems}
%% 
%%   \begin{itemize}
%%     \item<1-> All verification systems face the same problem: ergonomics
%%     \item<2-> If the system is obstructive, or even just perceived as such,
%%               people are unlikely to use it
%%     \item<3-> This is especially true for complex systems
%%     \begin{itemize}
%%       \item<4-> ``Fighting with the Rust borrow-checker''
%%       \item<5-> ``I'm experienced enough to write safe C/C++''
%%       \item<6-> ``I'm experienced enough to get the types right''
%%     \end{itemize}
%%   \end{itemize}
%% 
%% \end{frame}


%% MARK: PBT recap
\begin{frame}[fragile]
  \frametitle{Property Based Testing}

  \begin{itemize}
    \item<1-> QuickCheck is a Property Based Testing (PBT) framework initially
              developed for Haskell
    \item<2-> Define how to \emph{generate} an instance of a type, given some
              pseudorandom number generator state
      \begin{itemize}
        \item<2-> This is referred to as \mintinline{Idris}{Arbitrary}
      \end{itemize}
    \item<3-> Write \emph{properties} and \emph{generate} their test case inputs
  \end{itemize}

\end{frame}


%% MARK: Ty-lvl PBT
\begin{frame}[fragile]
  \frametitle{Type-Level Property Based Testing}

  \begin{itemize}
    \item<1-> In Idris2, the \mintinline{Idris}|So| type is inhabited iff its
              argument evaluates to \mintinline{Idris}|True|
    \item<2-> In other words, we can run property based testing as part of the
              type checking process!\\
              \mintinline{Idris}|So (quickCheck <property>)|
    \item<3-> Idris2 is built on Quantitative Type Theory, which has erasure,
              meaning the tests are removed from the compiled program
  \end{itemize}

\end{frame}


%% MARK: Gen Vect prob
\begin{frame}[fragile]
  \frametitle{Generating Dependent Types is Tricky}

  \begin{itemize}
    \item<1-> Consider generating arbitrary vectors:
              \begin{minted}[gobble=16]{Idris}
                Arbitrary t => Arbitrary (Vect n t)
              \end{minted}
    \item<2-> The type index \mintinline{Idris}|n| is implicit
    \item<3-> We cannot guarantee that the generated \mintinline{Idris}|Vect|
              will have some general, unspecified length \mintinline{Idris}|n|
    \item<4-> We could generate vectors of a specific length, but this is not
              ideal {\textemdash} an instance for each length
  \end{itemize}

\end{frame}


%% MARK: Arb Dep Ty.s
\begin{frame}[fragile]
  \frametitle{Arbitrary Dependent Types}

  \begin{itemize}
    \item<1-> The solution is more dependent types!
    \item<2-> Specifically: dependent pairs

    %\vspace*{-1mm}  % <2->
    \begin{minted}{Idris}
record DPair a (p : a -> Type) where
  constructor MkDPair
  fst : a
  snd : p fst
    \end{minted}
    %\vspace*{-1mm}

    \item<3-> As long as we know how to generate an {\textasciigrave
              \mintinline{Idris}{Arbitrary a}\textasciigrave}, we can generate
              an {\textasciigrave
              \mintinline{Idris}{Arbitrary (x : a ** p x)}\textasciigrave}
    \begin{itemize}
      \item<3-> (The \mintinline{Idris}{**} syntax is sugar for
                \mintinline{Idris}{DPair} / \mintinline{Idris}{MkDPair}
                depending on the context)
    \end{itemize}
  \end{itemize}

\end{frame}


%% MARK: Arb Vect
\begin{frame}[fragile]
  \frametitle{Arbitrary Vectors}

  \begin{itemize}
  \item<1-> We know how to generate the elements, so start by generating
            \textit{some} length
            \begin{minted}{Idris}
Arbitrary a => Arbitrary (n : Nat ** Vect n a) where
  arbitrary = do
    len <- arbitrary
            \end{minted}
  \item<2-> And then generate that many \mintinline{Idris}{arbitrary}
            elements
            \begin{minted}{Idris}
    vect <- nArbitrary len
    pure (len ** vect)
  where
    nArbitrary : (n : Nat) -> Gen (Vect n a)
    nArbitrary 0 = []
    nArbitrary (S k) = !arbitrary :: nArbitrary k
            \end{minted}
  \vspace*{-5mm}
  \end{itemize}

\end{frame}


%% MARK: Arb ATMs?
\begin{frame}[fragile]
  \frametitle{Arbitrary ATMs?}

  \begin{itemize}
    \item<1-> Can we do a similar thing for \mintinline{Idris}{ATMOp} and
              \mintinline{Idris}{ATM}?
    \item<2-> With a bit of work, yes!
  \end{itemize}

\end{frame}


%% MARK: Trace overview
\begin{frame}[fragile]
  \frametitle{A Bit of Work}

  \begin{itemize}
    \item<1-> Store the operation and its result instance {\textemdash}
              whether \mintinline{Idris}|PINok| was successful, for example
    \item<2-> Store an operation-result pair, and the state this moved
              us to
    \item<3-> A chain of these make up a \emph{trace}
  \end{itemize}

\end{frame}


%% MARK: Arb Trace
\begin{frame}
  \frametitle{Generating Traces}

  \begin{itemize}
    \item<1-> Given the current state, pattern matching allows the type checker
              to reduce the state function
    \item<2-> So we know which operations are possible
    \item<3-> Pick an arbitrary one, apply it, log its results, and repeat the
              process
  \end{itemize}


\end{frame}


%%% %% MARK: OpRes
%%% \begin{frame}[fragile]
%%%   \frametitle{Recording an Operation Happening}
%%% 
%%%   \begin{minted}[gobble=4]{Idris}
%%%     record OpRes {0 stT : _} (opT : (t’ : _) -> stT -> (t’ -> stT) -> Type) ... where
%%%       constructor MkOpRes
%%%       op : opT resT currSt nsFn
%%%       res : resT
%%%       {auto opShow : Show (opT resT currSt nsFn)}
%%%       {auto rShow : Show resT}
%%%   \end{minted}
%%% 
%%% \end{frame}
%%% 
%%% 
%%% %% MARK: TraceStep
%%% \begin{frame}[fragile]
%%%   \frametitle{Tracing a State Transition}
%%% 
%%%   \begin{minted}[gobble=4]{Idris}
%%%     record TraceStep (opT : (t’ : _) -> stT -> (t’ -> stT) -> Type) where
%%%       constructor MkTS
%%%       opRes : OpRes opT stepRT stepSt stepFn
%%%       resSt : stT
%%%   \end{minted}
%%% 
%%% \end{frame}
%%% 
%%% 
%%% %% MARK: Trace
%%% \begin{frame}[fragile]
%%%   \frametitle{Tracing Sequences of State Transitions}
%%% 
%%%   \begin{minted}[gobble=4]{Idris}
%%%     data Trace : (opT : (t’ : _) -> stT -> (t’ -> stT) -> Type) -> ... -> Type where
%%%       MkTrace : Show stT => (initSt : stT) -> {bound : Nat}
%%%               -> (trace : Vect bound (TraceStep opT))
%%%               -> Trace opT initSt bound
%%%   \end{minted}
%%% 
%%% \end{frame}
%%% 
%%% 
%%% \begin{frame}[fragile]
%%%   \frametitle{Arbitrary OpRes: Prerequisites}
%%% 
%%%   Provided we know what state we are currently in, we can generate an operation
%%%   and its result:
%%% 
%%%   \begin{minted}{Idris}
%%% {currSt : ATMState} ->
%%% Arbitrary (resT : _ ** nsFn : resT -> ATMState **
%%%            OpRes resT currSt nsFn)
%%% where
%%%           \end{minted}
%%% 
%%% \end{frame}
%%% 
%%% 
%%% \begin{frame}[fragile]
%%%   \frametitle{Arbitrary OpRes: from Ready}
%%% 
%%%   From \mintinline{Idris}{Ready}, we can insert the card:
%%% 
%%%   \begin{minted}{Idris}
%%%   arbitrary {currSt=Ready} =
%%%     pure (_ ** _ ** MkOpRes Insert ())
%%%   \end{minted}
%%% 
%%% \end{frame}


%% MARK: Options CI
\begin{frame}[fragile]
  \frametitle{ATM: from CardInserted}

  This is still QuickCheck, we can control the frequency of generated instances:

  \begin{minted}[fontsize=\footnotesize]{Idris}
options CardInserted = do
  -- we need a PIN, even though we control the result
  let arbPIN = 0
  let op1 = (_ ** _ ** MkOpRes (CheckPIN arbPIN) Correct)
  let op2 = (_ ** _ ** MkOpRes (CheckPIN arbPIN) Incorrect)
  let op3 = (_ ** _ ** MkOpRes Eject ())

  frequency $ [(1, pure op1), (4, pure op2), (1, pure op3)]
  \end{minted}

\end{frame}


%%% \begin{frame}[fragile]
%%%   \frametitle{Arbitrary OpRes: from Session}
%%% 
%%%   Generate an arbitrary amount to dispense, or eject the card:
%%% 
%%%   \begin{minted}{Idris}
%%% arbitrary {currSt=Session} = do
%%%   arbAmount <- arbitrary
%%%   let op1 = (_ ** _ ** MkOpRes (Dispense arbAmount) ())
%%%   let op2 = (_ ** _ ** MkOpRes Eject ())
%%%   oneof [pure op1, pure op2]
%%%   \end{minted}
%%% 
%%% \end{frame}
%%% 
%%% 
%%% \begin{frame}
%%%   \frametitle{Properties of the ATM}
%%% 
%%%   \begin{itemize}
%%%     \item<1-> Now that we have that, we can specify properties like\\
%%%               ``Within 5 state-transitions, we should be back in
%%%               \mintinline{Idris}{Ready}''
%%%               \vspace*{-1mm}
%%%               \inputminted{Idris}{qc-things/ATM-props.idr}
%%%     \item<2-> \textit{And} we can test it at compile-time
%%%               \vspace*{-1mm}
%%%               \inputminted{Idris}{qc-things/ATM-qc-props.idr}
%%%               \vspace*{-3mm}
%%%   \end{itemize}
%%% 
%%% \end{frame}


%% MARK: QC ATM error
\begin{frame}[fragile]
  \frametitle{QuickCheck Spots the Error!}

  \begin{minted}[gobble=4,fontsize=\footnotesize]{Idris}
    0 PROP_eventuallyReady : Fn (ATMTrace Ready 10) Bool
    PROP_eventuallyReady = MkFn
      (\case (MkATMTrace _ trace) => elem Ready (map (.resSt) trace))
  \end{minted}

  \pause

  With a property to eventually return to \mintinline{Idris}|Ready|, the file no
  longer type checks:

  \inputminted{Idris}{qc-things/ATM-qc-error.idr}

\end{frame}


%% MARK: QC ATM error
\begin{frame}[fragile]
  \frametitle{QuickCheck Gives a Trace}

  \begin{itemize}
    \item<1-> Investigating by running QuickCheck at the REPL, the error is
              exactly the fault in the model:
              \vspace*{1mm}
              \inputminted[fontsize=\scriptsize]{Idris}{qc-things/qc-trace-4.idr}
              \vspace*{-4mm}
  \end{itemize}

\end{frame}


%% TODO: Frame on dep ty.s being ty-lvl prog.s


%% MARK: Fixing things
\begin{frame}[fragile]
  \frametitle{Fixing Things}

  \begin{itemize}
    \item<1-> Now that we know there's an error, we can fix things!
              \begin{minted}[gobble=16]{Idris}
                ChkPINfn : (retries : Nat) -> PINok -> ATMState
                ChkPINfn 0     Correct   = Session
                ChkPINfn 0     Incorrect = Ready
                ChkPINfn (S k) Correct   = Session
                ChkPINfn (S k) Incorrect = CardInserted k
              \end{minted}

    \item<2-> Carrying this through to the generators, our property passes: the
              file reloads successfully and the REPL reports
              \begin{minted}[gobble=16]{Idris}
                > QuickCheck PROP_eventuallyReady
                MkQCRes (Just True) <log> "OK, passed 100 tests"
              \end{minted}
  \end{itemize}

\end{frame}


%% MARK: Mod, verif, impl
\begin{frame}
  \frametitle{Model, Verification, and Implementation}
  \begin{itemize}
    \item<1-> With most verification tools, we have to translate between models
    \begin{itemize}
      \item<1-> Spec, model, and implementation are independent
    \end{itemize}
    \item<2-> This results in the risk of translation mistakes
    \begin{itemize}
      \item<2-> Might think we're verifying the same thing, when in actual fact
                the semantics have changed between representations
    \end{itemize}
  \end{itemize}

\end{frame}


%% MARK: Generic trace
\begin{frame}[fragile]
  \frametitle{All in one}

  
  In our case, the specification \textit{is} the model; \textit{everywhere}

  \inputminted{Idris}{qc-things/ATM-arb-trace.idr}

  \pause

  And this works for anything expressed in terms of states, results, and
  operations {\textemdash} ISMs generalise

\end{frame}


%% MARK: Testing the types
\begin{frame}
  \frametitle{We Are Testing Types!}

  \begin{itemize}
    \item<1-> We have not tested the implementation
    \item<2-> We have tested the dependent types which help guide us when
              writing the implementation
    \item<3-> Which gives us confidence that our types capture the right
              behaviours
    \item<3-> Dependent types are type-level programs, let's test them!
  \end{itemize}

\end{frame}


%%% %% MARK: Benefits
%%% \begin{frame}
%%%   \frametitle{Benefits of a multifaceted approach}
%%% 
%%%   \begin{enumerate}
%%%     \item<1-> Adaptability {\textemdash} being able to use different tools
%%%     \item<2-> Speed {\textemdash} can trade speed for level of verification
%%%     \begin{itemize}
%%%       \item<2-> This isn't about proving things, it is about increasing
%%%                 confidence in our typed models
%%%       \item<3-> We could start adding proofs once the tests pass
%%%     \end{itemize}
%%%     \item<4-> \textbf{Coherence} {\textemdash} all done in one system
%%%       \begin{itemize}
%%%         \item<5-> Specification lives alongside model lives alongside
%%%                   implementation
%%%         \item<6-> The implementation is just there; it \emph{is} runnable code
%%%         \item<7-> Parts can be verified independently \emph{while} combined into an
%%%                   overall system
%%%       \end{itemize}
%%%   \end{enumerate}
%%% 
%%% \end{frame}


%%% \begin{frame}
%%% 
%%%   \begin{center}
%%%     \textcolor<1>{staDarkGreen}{\Large Thank you}
%%%   \end{center}
%%% 
%%% \end{frame}


\begin{frame}
  \frametitle{Links}

  \begin{center}
    {\large Email: {\href{mailto:teh6@st-andrews.ac.uk}{teh6@st-andrews.ac.uk}}}
  \end{center}

  \vspace*{-4mm}

  \begin{columns}
  \begin{column}{0.3\framewidth}
    \begin{center}
      Preprint
      \begin{figure}
        \includegraphics[width=\textwidth]{arxiv-qr.png}
      \end{figure}
      \href{https://doi.org/10.48550/arXiv.2407.12726}{arXiv:2407.12726}\vspace*{12mm}
    \end{center}
  \end{column}
  \begin{column}{0.3\framewidth}
    \begin{center}
      Code
      \begin{figure}
        \includegraphics[width=\textwidth]{code-qr.png}
      \end{figure}
      \href{https://github.com/CodingCellist/tyde-24-code}{GitHub: CodingCellist/tyde-24-code}
    \end{center}
  \end{column}
  \begin{column}{0.3\framewidth}
    \begin{center}
      Slides
      \begin{figure}
        \includegraphics[width=\textwidth]{slides-qr.png}
      \href{https://github.com/CodingCellist/tyde-24-code}{GitHub: CodingCellist/talks/2024-09-06-tyde-24-milan}\vspace*{3mm}
      \end{figure}
    \end{center}
  \end{column}
  \end{columns}

\end{frame}


%% MARK: Further work
\begin{frame}
  \frametitle{Further work}

  \begin{itemize}
    \item<1-> Running tests at the type level puts a lot of strain on the
              compiler, so there may be interesting optimisations to explore
              there
    \item<2-> Can we do more? ARQ with Sliding Window? Protocols with crash-stop
              failures?
    \item<3-> What kinds of properties can we test? There are parallels to Model
              Checking, so how does this compare to LTL or
              TLA\textsuperscript{+}?
  \end{itemize}

\end{frame}


%% MARK: Generic ISM
\begin{frame}[fragile]
  \frametitle{Generic ISM Datatype}

  \begin{minted}[gobble=4]{Idris}
    op : forall st . (t' : Type) -> st -> (t' -> st) -> Type

    data Prog : {0 stT : _} -> (opT : (t' : _) -> stT -> (t' -> stT) -> Type) -> (t : Type) -> (from : stT) -> (to : t -> stT) -> Type where
      Pure : (x : t) -> Prog opT t (stFn x) stFn
      Op : {0 opT : (t' : _) -> stT -> (t' -> stT) -> Type} -> opT t st stFn -> Prog opT t st stFn
      (>>=) : Prog opT resT1 st1 stFn1 -> ((x : resT1) -> Prog opT resT2 (stFn1 x) stFn2) -> Prog opT resT2 st1 stFn2
  \end{minted}

\end{frame}


%% MARK: OpRes details
\begin{frame}[fragile]
  \frametitle{Operation-Result Pairs}

  \begin{minted}[gobble=4]{Idris}
    record OpRes {0 stT : _} (opT : (t' : _) -> stT -> (t' -> stT) -> Type) (resT : Type) (currSt : stT) (0 nsFn : resT -> stT) where
      constructor MkOpRes
      op : opT resT currSt nsFn
      res : resT
      {auto opShow : Show (opT resT currSt nsFn)}
      {auto rShow : Show resT}
  \end{minted}

\end{frame}


%% MARK: TS details
\begin{frame}[fragile]
  \frametitle{TraceStep}

  \begin{minted}[gobble=4]{Idris}
    record TraceStep (opT : (t' : _) -> stT -> (t' -> stT) -> Type) where
      constructor MkTS
      {0 stepRT : _}
      {0 stepSt : stT}
      {0 stepFn : stepRT -> stT}

      opRes : OpRes opT stepRT stepSt stepFn
      resSt : stT

      {auto showStT : Show stT}
  \end{minted}

\end{frame}


%% MARK: TS details
\begin{frame}[fragile]
  \frametitle{Trace}

  \begin{minted}[gobble=4]{Idris}
    data Trace : (opT : (t' : _) -> stT -> (t' -> stT) -> Type) -> stT -> Nat -> Type where
      MkTrace : Show stT => (initSt : stT) -> {bound : Nat}
              -> (trace : Vect bound (TraceStep opT))
              -> Trace opT initSt bound
  \end{minted}

\end{frame}

\end{document}

