%\documentclass[compress]{beamer}
\documentclass[compress,handout]{beamer}

%%%%% PREAMBLE %%%%%

% we want to draw diagrams (turns out not like this though)
\usepackage{tikz}

% figures in a presentation look better without "Figure"
\usepackage{caption}
\captionsetup[figure]{labelformat=empty}

% for Idris syntax highlighting
\usepackage[styles]{idrislang}

% slide url at the end
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  urlcolor=purple
}

% N.B. For some reason, things don't build without this...
\usepackage{todonotes}
\setuptodonotes{inline} % for things to work nicely with beamer

%\usetheme{Zurich}  % doesn't work for some reason
%\usetheme{Flip}
\usetheme{metropolis}

\title{Increasing Confidence in Types}
%% TODO: subtitle?
%%\subtitle{Uniting the Spectrum of Verification}

\author{Thomas Ekstr{\" o}m Hansen}
\date{6\textsuperscript{th} March 2024}

\definecolor{staBlue}{HTML}{00539b}
\definecolor{staMidGreen}{HTML}{00853f}
\definecolor{staDarkGreen}{HTML}{005953}
\setbeamercolor{frametitle}{bg=staDarkGreen}


%%%%% DOCUMENT %%%%%

% /!\     N.B.: `fragile` required for listing to work     /!\

\begin{document}

\maketitle


\begin{frame}
  \frametitle{Overview}

  \begin{itemize}
    \item<1-> Many systems exhibit Finite State Machine (FSM)-like behaviour
    \begin{itemize}
      \item<1-> These can be neatly modelled with Dependent Types
    \end{itemize}
    \item<2-> ATM example of this from Edwin Brady's ``Type Driven
              Development with Idris'' book
    \begin{itemize}
      \item<2-> Turns out this example is subtly incorrect
    \end{itemize}
    \item<3-> How can we spot this? Can we increase confidence in our type-level
              modelling without having to ``just get it right''?
    \item<4-> Spoilers: How does QuickCheck fit in with dependent types?
    \item<5-> No silver bullet, but we can hopefully catch errors faster and
              have some guarantees that our model behaves as intended
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{The ATM state machine}

  \begin{center}
  \begin{figure}
    \begin{tikzpicture}[> = stealth, thick,
                        roundnode/.style={circle, draw=black!100, minimum size=16mm},
                        node distance=2cm and 3cm]
      % ATM states %
      \node [circle, draw=black!100, minimum size=14mm] {} ;
      \node[roundnode] (st-ready) {Ready} ;
      \node[roundnode] (st-card) [right=of st-ready, align=center] {\small Card\\\small inserted} ;
      \node[roundnode] (st-session) [below=of st-ready] {Session} ;

      % Arrows %
      \draw [->] (st-ready.north east) -- (st-card.north west)
            node [above, midway] {InsertCard} ;

      \draw [->] (st-card.south west) -- (st-ready.south east)
            node [below, midway] {Eject} ;
      \draw [->] (st-card.south) -- (st-session.east)
            node [right, midway, xshift=1pt, yshift=-1mm] {\small CheckPIN?(Correct)} ;

      \draw [->] (st-session.north) -- (st-ready.south)
            node [left, midway] {Eject} ;

      % Lööps %
      \draw [->] (st-card) to[loop above]
            node [right, xshift=3mm, yshift=-5mm] {\footnotesize GetPIN!(PIN)}
            () ;
      \draw [->] (st-card) to[loop right]
            node [below, xshift=3mm, yshift=-3mm] {\scriptsize CheckPIN?(Incorrect)}
            () ;
      \draw [->] (st-session) to[loop left]
            node [below, xshift=2mm, yshift=-2mm] {\footnotesize Dispense} () ;
    \end{tikzpicture}

    \caption{State machine of an ATM}
  \end{figure}
  \end{center}

\end{frame}


\begin{frame}
  \frametitle{Indexed State Monads (ISMs)}

  % TODO: try to get this nicer via minted?
  \vspace*{-3mm}
  \idrisinput{qc-things/ATM.idr}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Using the operations}

  \begin{itemize}
    \item<1-> Using the ISM operations requires another ISM, defining
              \texttt{pure}, \texttt{op}, \texttt{bind}, and \texttt{seq}
  \end{itemize}

  \pause

  \begin{idrislisting}
data ATM : (t : Type) -> ATMSt -> (t -> ATMSt) -> Type
  where
  Pure : (x : t) -> ATM t (stFn x) stFn
  Op : ATMOp t st st' -> ATM t st st'
  (>>=) :  ATM a s1 s2f -> ((x : a) -> ATM b (s2f x) s3f)
        -> ATM b s1 s3f
  (>>) :  ATM () s1 s2f -> (ATM b (s2f ()) s3f)
       -> ATM b s1 s3f
  \end{idrislisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Programming with ISMs}

  \begin{itemize}
    \item<1-> We declare our intended start and end state in the type
    \item<2-> And the type-checker verifies that we don't use commands incorrectly
  \end{itemize}

  \vspace*{-5mm}

  \pause

  \begin{idrislisting}
  prog : ATM () Ready (const Ready)
  prog = do
    Op Insert
    Correct <- Op $ CheckPIN 1234
      | Incorrect => <...>
    amount <- Op GetAmount
    Op $ Dispense amount
    Op Eject
  \end{idrislisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Using types only gets you part of the way there}

  \begin{columns}
  \begin{column}{0.47\framewidth}
    {\color{red} Rejected by the type-checker:}
    \vspace*{-3mm}
    \begin{idrislisting}[basicstyle=\ttfamily\scriptsize]
badProg : ATM ()
            Ready (const Ready)
badProg = do
  Op Insert
  let pin = 1234
  Correct <- Op $ CheckPIN pin
    | Incorrect => InsertCard
  amt <- Op GetAmount
  Op $ Dispense amt 
  -- We never Eject, so we
  -- never come back to
  -- `Ready'
    \end{idrislisting}
  \end{column}

  \pause  % first show the bad, then the dubious

  \hspace*{-0.6mm}
  \vrule{}

  \begin{column}{0.53\framewidth}
    {\color{orange} Accepted by the type-checker:}
    \vspace*{-3mm}
    \begin{idrislisting}[basicstyle=\ttfamily\scriptsize]
loopProg : CMD ()
            Ready (const Ready)
loopProg = do
    Op InsertCard
    let pin = 4321
    loopIncorrect pin
  where
    loopIncorrect : Nat -> ATM ()
                      CardInserted
                      (const Ready)
    loopIncorrect p = do
      Incorrect <- Op $ CheckPIN p
        | Correct => <...>
      loopIncorrect p
    \end{idrislisting}
    \vspace*{-6mm}
  \end{column}
  \end{columns}
\end{frame}


\begin{frame}
  \frametitle{Why is this a problem?}

  \begin{itemize}
    \item<1-> We expect an ATM to reject the card after 3 PIN attempts
    \begin{itemize}
      \item<1-> Not to be permanently unavailable if we retry forever
    \end{itemize}
    \item<2-> However, the programmer is unlikely to catch this
    \item<3-> The model looks correct and rigorous, after all
    \item<4-> Programming with it will catch most errors
    \item<5-> And the type-checker is happy with our sequence of operations
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{How do we solve this?}

  \begin{itemize}
    \item<1-> We could spot the issue when it happens
    \begin{itemize}
      \item<2-> Someone will (hopefully) spot the issue during development
      \item<3-> Or, worst case, spot it when it happens after deployment
    \end{itemize}
    \item<4-> And then we update our model and everything is good
    \item<5-> Why not try to spot it \textit{automatically} before either of
              those?
    \item<6-> Modelling can clearly go wrong, so how do we increase our
              confidence in the models? Who type-checks the types?
  \end{itemize}
\end{frame}


%% FIXME: is this relevant for the talk?
%% \begin{frame}
%%   \frametitle{There are patterns in these}
%%   \todo{Is this relevant for the talk?}
%%
%%   \begin{itemize}
%%     \item The \texttt{Bind}, \texttt{Seq}, and \texttt{Pure} commands are always
%%           the same
%%     \begin{enumerate}
%%       \item Given a state, a result, and what to do next, can bind from state 1
%%             to state 3
%%       \item Trivially so if the result is \texttt{Unit}
%%       \item And if we have a value, we can shove it in a state as long as the
%%             state function accepts something of the value's type
%%     \end{enumerate}
%%     \item State-names map to \texttt{CMD} constructors
%%     \item And dependent states' pattern-matches can be lifted to
%%           \texttt{<...>Res} types
%%   \end{itemize}
%%
%% \end{frame}


\begin{frame}[fragile]
  \frametitle{Spectrum of Verification}

  \hspace*{-5mm}  % to fit the bounding box of the tikz diagram
  % ~~probably~~ definitely cursed
  \begin{tikzpicture}[> = stealth, semithick]
    % scale %

    % left half
    \draw [dashed, <-] (-0.2, 0) -- (0.4, 0) ;
    \draw (0.4, 0) -- (3.8, 0) ;

    % middle dashed
    \draw [dashed] (3.8, 0) -- (6.6, 0) ;

    % right half
    \draw (6.6, 0) -- (10, 0) ;
    \draw [dashed, ->] (10, 0) -- (10.6, 0) ;


    % ticks / vertical lines %

    % leftmost tick (constructive proofs)
    \draw<2-> (0.8, -0.5) -- (0.8, 0.5) ;
    
    % tick for model checking
    \draw<3-> (3, -0.5) -- (3, 0.5) ;

    % tick for Quickcheck
    \draw<4-> (7.3, -0.5) -- (7.3, 0.5) ;

    % rightmost tick (unit tests)
    \draw<5-> (9.4, -0.5) -- (9.4, 0.5) ;


    % scale labels %

    \node at (0, -0.3) {\scriptsize Stronger} ;
    \node at (10.3, -0.3) {\scriptsize Weaker} ;


    % text boxes with arrows %

    % constructive proofs
    \node<2->
          [draw, rounded corners,
          text width=7em,
          align=flush center,
          color=staBlue]% 
          at (1.5, 2.3)
          (tbox-prf)
          \bgroup
          \scriptsize
          Constructive proofs
          \vspace*{-2pt}
          \tiny
          % LaTeX looks beautiful and nice
          % Also LaTeX:
          \setlength{\leftmargini}{2em}
          \begin{itemize}%[leftmargin=*]
            \item CoQ/RoCQ, Agda, Isabelle \vspace*{-3pt}
            \item Very strong guarantees \vspace*{-3pt}
            \item Hard to write
          \end{itemize}
          \egroup
          ;
    \draw<2-> [thick, color=staBlue] (tbox-prf) -- (0.8, 0.5) ;

    % model checking
    \node<3->
          [draw, rounded corners,
          text width=6em,
          align=flush center,
          color=staBlue]% 
          at (2.5, -2)
          (tbox-mc)
          \bgroup
          \scriptsize
          Model checking
          \vspace*{-3pt}
          \tiny
          \setlength{\leftmargini}{2em}
          \begin{itemize}%[leftmargin=*]
            \item \textsc{Spin, Uppaal}  \vspace*{-3pt}
            \item Exhaustive search  \vspace*{-3pt}
            \item Doesn't scale
          \end{itemize}
          \egroup
          ;
    \draw<3-> [thick, color=staBlue] (tbox-mc) -- (3, -0.5) ;

    % property-based testing
    \node<4->
          [draw, rounded corners,
          text width=8em,
          align=flush center,
          color=staBlue]% 
          at (6, 2)
          (tbox-qc)
          \bgroup
          \scriptsize
          Property-based testing
          \vspace*{-3pt}
          \tiny
          \setlength{\leftmargini}{2em}
          \begin{itemize}%[leftmargin=*]
            \item QuickCheck, JQF \vspace*{-3pt}
            \item Generates inputs for each property \vspace*{-3pt}
            \item Might miss cases
          \end{itemize}
          \egroup
          ;
    \draw<4-> [thick, color=staBlue] (tbox-qc) -- (7.3, 0.5) ;

    % tdd
    \node<5->
          [draw, rounded corners,
          text width=8em,
          align=flush center,
          color=staBlue]% 
          at (7.5, -2)
          (tbox-tdd)
          \bgroup
          \scriptsize
          Unit testing / TDD
          \vspace*{-3pt}
          \tiny
          \setlength{\leftmargini}{2em}
          \begin{itemize}%[leftmargin=*]
            \item JUnit, unittest, cfg(test) \vspace*{-3pt}
            \item Easy to write \vspace*{-3pt}
            \item Only tests what the programmer has thought of
          \end{itemize}
          \egroup
          ;
    \draw<5-> [thick, color=staBlue] (tbox-tdd) -- (9.4, -0.5) ;

  \end{tikzpicture}

\end{frame}


\begin{frame}
  \frametitle{The eternal problem with verification systems}

  \begin{itemize}
    \item<1-> All verification systems face the same problem: ergonomics
    \item<2-> If the system is obstructive, or even just perceived as such,
              people are unlikely to use it
    \begin{itemize}
      \item<3-> This is especially true for complex systems
      \item<3-> ``Fighting with the Rust borrow-checker''
      \item<3-> ``I'm experienced enough to write safe C/C++''
    \end{itemize}
    \item<4-> Where does Idris fit in here?
      \begin{itemize}
        \item<5-> Allows us to target all areas of the spectrum
        \item<6-> Compiler and type-system assist you rather than hinder
        \item<7-> Verify as you go along, tuning the strictness as necessary
        \item<8-> Unit tests are not thorough enough, so QuickCheck seems like a
                  good middle ground
        \item<9-> Dependent types allow us to run the tests at compile time, and
                  linearity to erase their results at runtime!
      \end{itemize}
  \end{itemize}

  \vspace*{-5mm}

\end{frame}


\begin{frame}
  \frametitle{How do you generate a dependent type?}

  \begin{itemize}
    \item<1-> QuickCheck's bread and butter is \texttt{Arbitrary}
    \begin{itemize}
      \item<2-> Define how to generate an instance of a type, given some
            pseudorandom number generator state
      \item<3-> Reasonably straightforward for random numbers, picking an
                element, and structures where the type of the constructors are
                known at generation-time
    \end{itemize}
    \item<3-> However, our types are \textit{dependent}
    \item<4-> So we cannot know the exact type at generation time
    \begin{itemize}
      \item<5-> We can know \textit{a} type, but not all. For example,
                \texttt{Vect 3 Nat} is trivial: \texttt{[!arbitrary, !arbitrary,
                !arbitrary]}
      \item<6-> The problem is \texttt{Vect n Nat}
      \item<7-> Or even \texttt{Arbitrary t $=>$ Vect n t}
    \end{itemize}
  \end{itemize}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Arbitrary dependent types}

  \begin{itemize}
    \item<1-> The solution is more dependent types!
    \item<2-> Specifically: dependent pairs

    \vspace*{-6mm}
    \begin{idrislisting}<2->
record DPair a (p : a -> Type) where
  constructor MkDPair
  fst : a
  snd : p fst
    \end{idrislisting}
    \vspace*{-3mm}

    \item<3-> As long as we know how to generate an {\textasciigrave
              \texttt{Arbitrary a}\textasciigrave}, we can generate an
              {\textasciigrave\texttt{Arbitrary (x : a ** p x)}\textasciigrave}
    \begin{itemize}
      \item<3-> (The \texttt{**} syntax is sugar for
                \texttt{DPair}/\texttt{MkDPair} depending on the context)
    \end{itemize}
  \end{itemize}

\end{frame}


%% FIXME: include this?
%%
%% \begin{frame}[fragile]
%%   \frametitle{Arbitrary vectors}
%% 
%%   \begin{itemize}
%%   \item To generate an arbitrary vector, we generate \textit{some} length\dots
%%   \item \dots\ and then generate that many \textasciigrave
%%         \texttt{arbitrary}\textasciigrave elements
%%   \end{itemize}
%% 
%%   \vspace*{-5mm}
%% 
%%   \begin{idrislisting}
%% Arbitrary a => Arbitrary (n : Nat ** Vect n a) where
%%   arbitrary = do
%%     len <- arbitrary
%%     pure (len ** nArbitrary len)
%%   where
%%     nArbitrary : (n : Nat) -> Gen (Vect n a)
%%     nArbitrary 0 = []
%%     nArbitrary (S k) = !arbitrary :: nArbitrary k
%%   \end{idrislisting}
%% 
%% \end{frame}


\begin{frame}[fragile]
  \frametitle{Plumbing for operations}

  \idrisinput{qc-things/ATM-opres.idr}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Tracing ATMs}

  \idrisinput{qc-things/ATM-tracing.idr}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Generating arbitrary OpRes}

  \vspace*{-2mm}
  \idrisinput{qc-things/ATM-arb-opres.idr}

\end{frame}


\begin{frame}
  \frametitle{Properties of the ATM}

  \begin{itemize}
    \item<1-> As you can see, generating arbitrary ATM steps is a bit more
              involved than non-dependent types, but it is doable
    \item<2-> And now that we have that, we can specify properties like\\
              ``Within 5 state-transitions, we should be back in
              {\textasciigrave\texttt{Ready}\textasciigrave}''
              \vspace*{-5mm}
              \idrisinput{qc-things/ATM-props.idr}
              \vspace*{-2mm}
    \item<3-> \textit{And} we can test it at compile-time
              \vspace*{-5mm}
              \idrisinput{qc-things/ATM-qc-props.idr}
              \vspace*{-2mm}
  \end{itemize}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Model, verification, and implementation all-in-one}

  \begin{itemize}
    \item<1-> With most verification tools, we have to translate between models
    \begin{itemize}
      \item<1-> Spec, model, and implementation are independent
    \end{itemize}
    \item<2-> This facilitates translation mistakes
    \begin{itemize}
      \item<2-> Might think we're verifying the same thing, when in actual fact
                the semantics have changed between representations
    \end{itemize}
    \item<3-> In our case, the specification \textit{is} the model; everywhere
  \end{itemize}

  \vspace*{-5mm}
  \idrisinput{qc-things/ATM-arb-trace.idr}
  \vspace*{-5mm}

\end{frame}


\begin{frame}
  \frametitle{QuickCheck spots the error!}

  \begin{itemize}
    \item<1-> If we try to type-check the file we get:
              \vspace*{-5mm}
              \idrisinput{qc-things/ATM-qc-error.idr}
    \item<2-> And if we investigate by running QC at the REPL, the error is
              exactly the fault in the model:
              \vspace*{-5mm}
              \idrisinput{qc-things/qc-trace-4.idr}
              \vspace*{-2mm}
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Benefits of a multifaceted approach}

  \todo{Ideally have a fixed version before this}

  \begin{enumerate}
    \item<1-> Adaptability {\textemdash} right tool for the job
    \item<2-> Speed {\textemdash} can trade speed for level of verification
    \item<3-> \textbf{Coherence} {\textemdash} all done in one system
      \begin{itemize}
        \item<4-> No need to translate to model-checking tool
        \item<5-> Specification lives alongside model lives alongside
                  implementation
        \item<6-> The implementation is just there; it \emph{is} runnable code
        \item<7-> Parts can be verified independently \emph{while} combining into an
                  overall system
      \end{itemize}
  \end{enumerate}

\end{frame}


\begin{frame}
  \frametitle{Conclusion}

  \begin{itemize}
    \item<1-> Many verification tools exist, none of them cover enough on their
              own
    \item<2-> Instead of ``competing'', we combine the systems to work together
    \item<3-> Hopefully this will lead to wider adoption and better whole-system
              soundness
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Questions}

  \begin{center}
    \textcolor<1>{orange}{\Large Questions?}
  \end{center}

\end{frame}

%% TODO
%% \begin{frame}
%%   \frametitle{Slides}
%% 
%%   \begin{center}
%%     \begin{figure}
%%       \includegraphics[width=0.35\framewidth]{qr-code.png}
%%       \caption{\href{https://github.com/CodingCellist/talks/blob/main/2024-03-06-slps-st-andrews}{github.com/CodingCellist/talks}}
%%     \end{figure}
%%   \end{center}
%% 
%% \end{frame}

\end{document}

